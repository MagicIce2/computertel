### 简介

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

23种设计模式：

- **创建型模式：关注对象的创建过程**
  - 工厂模式（Factory Pattern）：定义一 个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
  - 抽象工厂模式（Abstract Factory Pattern）：为创建一组相关或相互依赖的对象提供一个接 口，而且无须指定它们的具体类
  - 单例模式（Singleton Pattern）：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
  - 建造者模式（Builder Pattern）：将一个复杂对象 的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 
  - 原型模式（Prototype Pattern）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。(通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。)
- **结构型模式：是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题（关注对象和类的组织）**
  - 适配器模式（Adapter Pattern）：将一个类的接口变换成客户端所期待的另一种接口，从 而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 （使原本由于接口不兼容不能一起工作的类可以一起工作）
  - 桥接模式（Bridge Pattern）：将抽象和实现解耦，使得两者可以独立地变化。 （处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联）
  - //过滤器模式（Filter、Criteria Pattern）
  - 组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得 用户对单个对象和组合对象的使用具有一致性。 （将对象组合成树状结构以表示“部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器的对象）
  - 装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就增加功能来 说，装饰模式相比生成子类更为灵活。 （动态地给一个对象添加额外的功能，比继承灵活）
  - 外观模式（Facade Pattern）：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模 式提供一个高层次的接口，使得子系统更易于使用。 （为子系统提供统一的调用接口，使得子系统更加容易使用）
  - 享元模式（Flyweight Pattern）：使用共享对象可有效地支持大量的细粒度的对象。 （运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率）
  - 代理模式（Proxy Pattern）：为其他对象提供一种代理以控制对这个对象的访问。 （为真实对象提供一个代理，从而控制对真实对象的访问）
- **行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责**
  - 责任链模式（Chain of Responsibility Pattern）：使多个对象都有机会 处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连 成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 (避免请求发送者和接收者耦合，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿着这条链传递请求，直到有对象处理为止。)
  - 命令模式（Command Pattern）： 将一 个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排 队或者记录请求日志，可以提供命令的撤销和恢复功能。 (将一个请求封装为一个对象，从而使得请求调用者和请求接收者解耦)
  - 解释器模式（Interpreter Pattern）： 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解 释器使用该表示来解释语言中的句子。 （描述如何为语言定义一个文法，如何解析）
  - 迭代器模式（Iterator Pattern）：它提供一种方法访问一个容器对象中各 个元素，而又不需暴露该对象的内部细节。 （提供了一种方法来访问聚合对象）
  - 中介者模式（Mediator Pattern）：用一个中介对象封 装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合 松散，而且可以独立地改变它们之间的交互。 (通过一个中介对象来封装一系列的对象交互，使得各对象不需要相互引用)
  - 备忘录模式（Memento Pattern）： 在不破坏封装 性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样 以后就可将该对象恢复到原先保存的状态。 （捕获一个对象的内部状态，并保存之；需要时，可以恢复到保存的状态）
  - 观察者模式（Observer Pattern）：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态， 则所有依赖于它的对象都会得到通知并被自动更新。 （当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新）
  - 状态模式（State Pattern）：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 （允许一个对象在其内部状态改变时改变它的行为）
  - //空对象模式（Null Object Pattern）
  - 策略模式（Strategy Pattern）：定义一组算法，将每个算法都封装起来，并且使它们之间可以 互换。 （定义一系列算法，并将每个算法封装在一个类中 ）
  - 模板模式（Template Pattern）：定义一个操作中的算法的 框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可 重定义该算法的某些特定步骤。 (定义一个操作的算法骨架，将某些易变的步骤延迟到子类中实现)
  - 访问者模式（Visitor Pattern）：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的 操作。 （表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下定 义作用于这些元素的新操作）
- J2EE 模式
  - MVC 模式（MVC Pattern）
  - 业务代表模式（Business Delegate Pattern）
  - 组合实体模式（Composite Entity Pattern）
  - 数据访问对象模式（Data Access Object Pattern）
  - 前端控制器模式（Front Controller Pattern）
  - 拦截过滤器模式（Intercepting Filter Pattern）
  - 服务定位器模式（Service Locator Pattern）
  - 传输对象模式（Transfer Object Pattern）

**设计模式之间的关系**：

![https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

##### 设计模式的六大原则

- 开闭原则：对扩展开放，对修改关闭；在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；为了程序的扩展性好，易于维护和升级（需要使用接口和抽象类）。
- 里氏代换原则：任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石；里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象画，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
- 依赖倒转原则：是**开闭原则**的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
- 接口隔离原则：使用多个隔离的接口，比使用单个接口要好（降低类之间的耦合度）；强调低依赖，降低耦合。
- 迪米特法则（最少知道原则）：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
- 合成复用原则：尽量使用合成/聚合的方式，而不是使用继承。

### 一、<a href="https://www.runoob.com/design-pattern/factory-pattern.html">工厂模式</a>（多态、面向接口编程思想）

分类：

- 简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已 有代码） 
- 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品） 
- 抽象工厂模式： 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持 增加产品族） 

属于创建型模式，它提供了一种创建对象的最佳方式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

模式中包含的角色及其职责：

- 工厂角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。
- 抽象角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
- 具体产品角色：简单工厂模式所创建的具体实例对象

**优点：** 

- 1、一个调用者想创建一个对象，只要知道其名称就可以了。 

- 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
- 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：**

- 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
- 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
- 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**example**：

```java
//抽象角色
public interface Fruit {    
    void get();
}
```

```java
public class Apple implements Fruit{    
    /**     
    * 采集     
    */    
    public void get(){        
        System.out.println("采集苹果！");    
    }
}
```

```java
public class Banana implements Fruit{    
    /**     
    * 采集     
    */    
    public void get(){        
        System.out.println("采集香蕉！");    
    }
}
```

```java
//工厂角色
public class FruitFactory {    
    /**     
    * 获得 Apple 类的实例     
    */    
    public static Fruit getApple(){        
        return new Apple();    
    }  
    
    /**     
    * 获得 Banana 类实例     
    */    
    public static Fruit getBanana(){        
        return new Banana();    
    }
}
```

```java
public class Test {    
    @org.junit.Test    
    public void factoryTest(){        
        //实例化一个 Apple
        //        Apple apple = new Apple();
        //        实例化一个 Banana
        //        Banana banana = new Banana();        
        Fruit apple = FruitFactory.getApple();        
        Fruit banana = FruitFactory.getBanana();        
        apple.get();        
        banana.get();    
    }
}
```

### 二、抽象工厂模式

围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式；在抽象工厂模式中，接口负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景**：

- 1、QQ 换皮肤，一整套一起换。
- 2、生成不同操作系统的程序

**UML图**：

![1561618400334](img\1561618400334.png)

### 三、单例模式

提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**饿汉式**单例模式实现方式在类加载到内 存的时候，就创建好对象了，而**懒汉式**则是在第一次使用的时候才创建对象， 也就是把创建对象的时机从加载延迟到第一次使用，

**优点：**

-  1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
-  2、避免对资源的多重占用（比如写文件操作）。 

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

**使用场景：**

-  1、要求生产唯一序列号。 
-  2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
-  3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

**UML图**：

![1561631139666](img\1561631139666.png)

### 四、建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。 

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 

**使用场景：** 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 

**UML图**：

![1561693795542](img\1561693795542.png)

### 五、原型模型

用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**优点：** 1、性能提高。 2、逃避构造函数的约束。 

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。  

**使用场景：** 

1、资源优化场景。 

2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。

 3、性能和安全要求的场景。 

4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

 5、一个对象多个修改者的场景。

 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 

7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 

**UML图**：

![1561706971559](img\1561706971559.png)

### 六、适配器模式

作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

**优点：** 

1、可以让任何两个没有关联的类一起运行。 

2、提高了类的复用。 

3、增加了类的透明度。 

4、灵活性好。 

**缺点：** 

1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 

2、由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 

**使用场景：**有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

![1561707565064](img\1561707565064.png)

