[Java虚拟机](https://blog.csdn.net/qq_41701956/article/details/81664921)

Java虚拟机中内存的划分

- 寄存器：CPU处理
- 本地方法区
- 方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 栈内存：存储的都是局部变量
- 堆内存：存储的是数组和对象（其实数组就是对象），凡是 new 建立的都在堆中

实体是用来封装数据的，每个实体都有首地址值，堆内存中的变量会有默认初始化值

#### 类与对象

先属性后行为，即先声明再方法（先定义，再使用）

局部变量（方法内）会暂时屏蔽成员变量（类中），局部变量无默认值

如在局部变量中使用成员变量则需 **this** 关键字

**成员变量在类中，局部变量在方法中**

构造方法（给成员变量赋值，没有类型）

- 默认构造方法：无参数
- 自定义构造方法：可以有参数

对于引用型，默认初始值为 null

new 运算符只能和类的构造方法进行运算，运算的结果是一个十六进制的数

ps：**对象的引用存在栈中，对象的实体（分配给对象的变量）存在堆中**

**参数传值**

- 基本类型的参数的传值：**拷贝**
- 引用类型参数的传值：传递的是变量中存放的“引用”，而不是变量所引用的实体；**改变值则会变，改变引用则不变**
- 可变参数：“…”；表示若干个参数，这些参数的**类型必须相同**，并且最后一个参数必须是方法的参数列表中的最后一个参数

**实例成员与类成员**

- 实例变量和类变量（也称为 static 变量、静态变量）

  ```java
  /*
  区别：
  1、不同对象的实例变量互不相同（分配给不同对象的实例变量占有不同的内存空间，改变其中一个对象的实例变量不会影响其他对象的实例变量）
  2、所有对象共享类变量（改变其中一个对象的这个类变量会影响其他对象的这个类变量；对象共享类变量）
  3、通过类名直接访问类变量
  */
  
  class Dog{
      float x;		//实例变量
      static int y;	//类变量
  }
  ```

- 实例方法和类方法

  ```java
  /*
  区别：
  1、对象调用实例方法
  2、类名调用类方法
  3、设计类方法的原则（对于 static 方法，不必创建对象就可以用类名直接调用它【创建对象会导致类中的实例变量被分配内存空间】，如果一个方法不需要操作类中的任何实例变量，就可以考虑将这样的方法设计为 static 方法）
  */
  class A{
      
      int a;
      
      float max(float x, float y){	//实例方法
          ...
      }
      
      static float jerry(){			//类方法（静态方法）
          ...
      }
      
      static void speak(String s){	//类方法
          ...
      }
  }
  ```

**方法重载**

- 参数的个数不同
- 参数个数相同，但参数列表中对应的某个参数的类型不同

**this 关键字**

this 可以出现在实例方法和构造方法中，但不可以出现在类方法中

- this 出现在类的构造方法中时，代表使用该构造方法所创建的对象
- 实例方法只能通过对象来调用，不能用类名来调用。当 this 关键字出现在实例方法中时，this 就代表正在调用该方法的当前对象。

**包 package**

对类文件进行分类管理，给类提供多层命名空间，写在程序文件的第一行，类名的全称是 **包名.类名** 包也是一种封装形式

import 可以导入包中的类文件（并不导入包，为了简化类名书写）

导包原则：用到哪个类，就导入哪个类

**访问权限**

public、protected、default（包访问权限）、private

| 访问权限  | 本类 | 本包的类 | 子类 | 非子类的外包类 |
| :-------: | :--: | :------: | :--: | :------------: |
|  public   |  是  |    是    |  是  |       是       |
| protected |  是  |    是    |  是  |       否       |
|  default  |  是  |    是    |  否  |       否       |
|  private  |  是  |    否    |  否  |       否       |

1、**public：** 所修饰的类、变量、方法，在内外包均具有访问权限；
		2、**protected：** 这种权限是为继承而设计的，protected所修饰的成员，对所有子类是可访问的，但只对同包的类是可访问的，对外包的非子类是不可以访问；
		3、**包访问权限（default）：** 只对同包的类具有访问的权限，外包的所有类都不能访问；
		4、**private：** 私有的权限，只对本类的方法可以使用；

**注意：** 要区分开 protected 权限、包访问权限，正确使用它们；

- 当某个成员能被所有的子类继承，但不能被外包的非子类访问，就是用protected；
- 当某个成员的访问权限只对同包的类开放，包括不能让外包的类继承这个成员，就用包访问权限；

**代码块**

- 局部代码库：在方法内，方法调用时执行（限定局部变量的生命周期）

- 构造代码块：在方法外，调用构造方法前执行

- 静态代码块：在方法外，static 修饰，在类加载时执行，且执行一次

  ```java
  class AAA{
  	static{
  		System.out.println("我是 AAA 中的静态块！");
  	}
  }
  
  
  public class E{
  	static{
  		System.out.println("我是最先被执行的静态块！");
  	}
  	public static void main(String args[]){
  		AAA a = new AAA();
  		System.out.println("我在了解静态（static）块");
  	}
  }
  
  //输出
  我是最先被执行的静态块！
  我是 AAA 中的静态块！
  我在了解静态（static）块
  ```

#### 子类与继承

子类隐藏父类中的同名方法

子类重写父类中的方法后，仍需访问父类的方法，可通过 super() 调用；

子类的继承：

- 可以继承父类中所有的公有内容（私有的内容不允许继承）

**instanceof** 运算符：判断某一个对象是否属于某一个类

**成员变量的隐藏和重写**

隐藏（所声明的成员变量的名字和从父类继承来的成员变量的名字相同【声明的类型可以不同】）

- 子类对象以及子类自己定义的方法操作与父类同名的成员变量是指子类重新声明的这个成员变量
- 子类对象仍然可以调用从父类继承的方法操作被子类隐藏的成员变量，也就是说，子类继承的方法所操作的成员变量一定是被子类继承或隐藏的成员变量

重写（方法的名字、参数个数、参数的类型和父类的方法完全相同）

**super 关键字**

如果在子类中想使用被子类隐藏的成员变量或方法，就需要使用 super 关键字

在子类的构造函数中第一行有一个默认的隐式语句。（super()）

super()；调用的就是父类中的空参数的构造函数

为什么子类实例化的时候要访问父类中的构造函数呢？

因为子类继承了父类，获取到了父类中内容（属性），所以在使用父类内容之前，要先看父类是如何对自己的内容进行初始化的。所以子类在构造对象时，必须访问父类中的构造函数，为了完成这个必须的动作，就在子类的构造方法中加入了 super() 语句。（ps：**super() 语句必须放在子类构造函数的第一行。因为父类的初始化动作要先完成，同时如果子类构造函数中使用 this 调用了本类构造函数时，那么 super 就没有了，super 和 this 都只能定义在第一行，所以只能有一个，但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造**）

子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数，因此，当在父类中定义多个构造方法时，应当包括一个不带参数的构造方法。

**final 关键字**

final 关键字可以修饰类、成员变量和方法中的局部变量

如果用 final 修饰父类中的一个方法，那么这个方法不允许子类重写。（不允许子类隐藏可以继承的 final 方法【不允许做任何篡改】）

如果成员变量或局部变量被修饰为 final，那它就是常量，（在运行期间不允许在发生变化，所以常量在声明时没有默认值，这就要求程序在声明常量时必须指定该常量的值）

**对象的上转型对象**

向上转型的目的是为了使用子类中的特有方法

对于转型，自始至终都是子类对象在做着类型的变化

**多态**（某一类事物的多张存在形态；当反类的引用指向子类对象时，只能使用父类的成员）

好处：提高了代码的扩展性，前期定义的代码可以使用后期的内容

弊端：前期定义的内容不能使用调用后期子类的特有内容

多态的前提：

- 必须有关系，继承，实现
- 要有覆盖

父类的成员方法如果被子类重写，执行子类

多态在代码中的提现：父类或者接口的引用指向其子类的对象，简单说：就是一个对象对应着不同类型

**abstract 类和 abstract 方法**

抽象类不允许直接实例化，必须通过具体子类来实现，不允许使用 final 和 abstract 同时修饰一个方法或类，也不允许使用 static 修饰 abstract 方法

多态时，成员的特点

1、成员变量：编译和运行都参考左边

2、成员函数：编译看左边，运行看右边

3、静态函数：编译和运行都看左边（其实对于静态方法，是不需要对象的，直接类名调用即可）

#### 接口与实现

接口：为了实现更多的功能，接口中的方法都是抽象方法

接口中常见的成员

- 全局常量

- 抽象方法

  ```java
  interface Printable{
      public static final int MAX = 100;			//等价于 int MAX = 100
      public abstract void add();					//等价于 void add()
      public abstract float sum(float x, float y);//
  }
  ```

如果一个非抽象类实现了某个接口，那么这个类必须重写这个接口中的所有方法。

类与类之间是继承关系

类与接口之间是实现关系

接口与接口之间是继承关系，而且接口可以多继承

一个类在继承另一个类的同时，还可以实现多个接口。接口的出现避免了单继承的局限性

如果一个类声明实现一个接口，但没有重写接口中的所有方法，那么这个类必须是抽象类，也就是说，抽象类既可以重写接口中的方法，也可以直接拥有接口中的方法

接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化，否则，这个子类就是一个抽象类

```java
interface Computable{
    final int MAX = 100;
    void speak(String s);
    int f(int x);
    float g(float x, float y);
}

abstract class A implements Computable{
    public int f(int x){
        int sum = 0;
        for(int i = 1; i <= x; i++){
            sum = sum + i;
        }
        return sum;
    }
}
```

**接口回调**（接口类型的引用，用于接收【指向】接口的子类的对象）

接口属于引用型变量，接口变量中可以存放实现该接口的类的实例的引用，即存放对象的引用

**抽象类和接口的异同点**

相同点：都是不断向上抽取而来的

不同点：

1. 抽象类需要被继承，而且只能单继承

   接口需要被实现，而且可以多实现

2. 抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用费抽象方法

   接口中只能定义抽象方法，必须由子类去实现

3. 抽象类的继承，是 is a 关系（所属关系）定义该体系的基本共性内容

   接口的实现是 like a 关系（像功能），在定义体系的额外功能

#### 内部类和异常类

内部类可以存放在局部位置上：内部类在局部位置上只能访问局部中被 final 修饰的局部变量

1、内部类可以直接使用外部类中的成员

2、外部类使用内部类的时候必须创建对象

一般用于类的设计：分析事物时，发现该事物中还有事物，而且这个事物还在访问被描述事物的内容，这时就把还有的事物定义成内部类来描述

如果内部类是静态的。相当于一个外部类；

如果内部类中定义了静态成员，该内部类也必须是静态的

为什么内部类能直接访问外部类中成员呢？

那是因为内部类持有了外部类的引用。外部类名.this

**匿名类**

必须有前提：内部类必须继承或者实现一个外部类或者接口

匿名内部类：其实就是一个匿名子类对象。格式：new 父类 or 接口 () {子类内容}

通常的使用场景之一：当函数参数是接口类型时，而且接口中的方法不超过三个。可以用匿名内部类作为实际参数进行传递

#### Java 多线程机制

其实应用程序的执行都是 CPU 在做着快速的切换完成的。这个切换是随机的。（时间片）

开启多个线程是为了同时运行多部分代码，每一个线程都有自己运行的内容，这个内容可以成为线程要执行的任务。

##### 进程与线程

**进程**：正在运行中的程序；一个进程中至少有一个线程

**线程**：就是进程中一个负责程序执行的控制单元（执行路径）；一个进程中可以有多条执行路径，称之为多线程

Java 的多线程机制：弊端；开的太多效率比较低下

主线程（main 线程）：主线程结束之后，虚拟机并不会立马结束，还有其他线程在运行

**线程的状态与生命周期**

CPU 的执行资格：在处理队列中排队，可以被 CPU 处理

CPU 的执行权：正在被 CPU 处理

![1563622835969](F:\localgit\computertel\img\1563622835969.png)

**线程的创建**

如何创建一个线程？

一、继承 Thread 类

1. 定义一个类继承 Thread 类
2. 覆盖 Thread 类中的 run 方法
3. 直接创建 Thread 的子类对象创建线程
4. 调用 start 方法，开启线程并调用线程的任务 run 方法执行

二、实现 Runable 接口

1. 定义类实现 Runable 接口

2. 覆盖接口中的 run 方法，将线程的任务代码封装到 run 方法中。

3. 通过 Thread 类创建线程对象，并将 Runable 接口的子类对象作为 Thread 类的构造函数的参数进行传递

   为什么？

   因为线程的任务都封装在 Runable 接口子类对象的 run 方法中。所以要在线程对象创建时就必须明确要运行的任务。

4. 调用线程对象的 start 方法开启线程

jvm 创建的主线程的任务都定义在了主函数中

Thread 类用于描述线程，线程是需要任务的。所以 Thread 类也是对任务的描述。这个任务就通过 Thread 类中的 run 方法来体现。也就是说，run 方法就是封装自定义线程运行任务的函数

run 方法中定义的就是线程要运行的任务代码

开启线程是为了运行指定代码，所以只有继承 Thread 类，并复写 run 方法。将运行的代码定义在 run 方法中即可。

创建线程的目的：开启一条执行路径，去运行指定的代码和其他代码实现同时运行

开启执行路径的目的：让一部分代码和其他代码同时运行

**实现 Runable 接口的好处**：

- 将线程的任务从线程子类中分类出来，进行了单独的封装，按照 OOP 的思想将任务封装成对象。
- 避免了 Java 单继承的局限性，所以创建线程的第二种方式较为常用

在使用多线程的时候呀，要考虑线程安全问题，产生的原因？

- 多个线程在操作共享的数据
- 操作共享数据的线程代码有多条

当一个线程在执行操作共享数据的多条代码过程中，其他线程也参与了运算，就会导致线程安全问题的产生。

在 Java 中，使用同步代码块就可以解决这个问题

```java
synchronized(对象){
    需要被同步的代码
}
```

**线程同步**（好处：解决了线程的安全问题）

同步的前提：必须有多个线程并使用用一个锁

弊端：相对降低了效率，因为同步外的线程都会判断同步锁

JDK 1.5 之后使用 lock() 函数处理锁的问题

同步函数和同步代码块的区别;

- 同步函数的锁是固定的 this
- 同步代码块的锁是任意的对象

静态的同步函数使用的锁是  该函数所属字节码文件对象

可以用 getClass 获取，也可以用当前  类名.class  表示

**协调同步的线程**

当一个线程使用的同步方法中用到某个变量，而此变量又需要其他线程修改后才能符合本线程的需要，那么可以使用 wait() 【使一个线程处于等待状态，并且释放所持有的对象 lock】方法。wait 方法可以中断线程的执行，使本线程等待，暂时让出 CPU 的使用权。

wait()、notify() 和 notifyAll() 都是 Object 类中的 final 方法，被所有的类继承且不允许重写的方法。（PS：不可以在非同步方法中使用 wait()、notify() 和 notifyAll() ）

#### 泛型和集合框架

待续…..